[
{
"url" : "/blog/linux.html",
"date" : "07.06.2024",
"title" :"&lt;del&gt;Windows&lt;/del&gt; Linux",
"content" : "Windows Linux 07.06.2024 My first computer was a Commodore Amiga 500. After Commodore went bankrupt, it was out of the question for me that the next computer would be a Windows PC, so I could play the latest and greatest games. And so it was an 486 with Windows 95. Over time, both the hardware and software were updated. And so I went through all the Windows iterations from 95/98/ME to XP/Vista/7 and then to 8/8.1/10 and 11. Besides playing games, I also took my first steps into the internet and expressed my creativity with Windows. Whether it was with my first drawings in Paint, designing my first HTML page with FrontPage, document design with Publisher, graphic design with Photoshop and Cinema4D, or animation with Flash. Later, programming was added to the mix. I felt quite comfortable with the past Windows versions. Of course, the removal of the Start menu in Windows 8 was annoying and Microsoft had to revise that decision. But otherwise, I really enjoyed working with Windows. It was smooth and snappy, old programs could be installed without problems, security kept getting better, and Windows rarely got in my way. Even Microsoft as a company seemed to be improving. It promoted open-source, integrated Linux into Windows, and released VSCode, an open-source editor, that I enjoy to work with in forensics and programming. Unfortunately, this phase didn’t last long, and Microsoft abandoned its statement that Windows 10 would be the last version. It started annoying me with constant requests for my data, including in the browser. Pop-ups suddenly appeared, demanding that I log in with my online account or upgrade to Windows 11. And OneDrive synchronized my desktop with the cloud after a reinstallation. It was a noticeable downhill slide. After upgrading to Windows 11, it seemed quite nice at first glance. Nice font rendering, friendlier design. But after the first updates, the Explorer became slower, placeholders were sometimes displayed instead of icons, the Start menu became slower, and the search was a joke. Windows was noticeably getting in my way for the first time and didn’t deserve the “Pro” in its name. I reinstalled Windows 10 on my systems to be able to work again. Shortly after, Microsoft announced that Windows 10 would only be supported for another year. The only thing that was still keeping me with Windows was only my convenience. With the announcement of planed advertising in Windows 11 and the presentation of Recall, a background process that takes screenshots of the desktop every few minutes, the path to a complete ad- and spyware has been paved, which is simply frightening and one that I definitely will not take. Microsoft has lost all respect for its users and I have lost all trust in Microsoft. After almost three decades, I now stand before the obvious choice of having to decide between Linux and MacOS. I have nothing against Apple as a user. They are an excellent innovator, have great designers, and produce some of the best hardware. Except for the discontinued butterfly keyboard and the reflective displays. In fact, I own an iPad Pro for reading and listening to podcasts and I really enjoy using it. I could even imagine getting a current 15” MacBook Air for writing and surfing if money were no object. As a developer, though, the decision is already predetermined in favor of an open system. There, I won’t be forced to make regular payments in order to beeing able to publish software for a system. I also won’t have to buy certificates to sign my software, just to make it appear more trustworthy. And no one will decide for me which software I can publish and which not. My first Linux experience was with Ubuntu in a VM on Windows. Maybe it was Ubuntu 14, maybe an earlier version. I don’t remember anymore. Initially out of curiosity, later as a forensic analyst and programmer. After getting used to it, I managed quite well with it, but out of convenience, I never really dealt with Linux in a sustained way until now. Even though I occasionally installed Linux as a dual-boot alongside Windows. For almost two months now, I’ve completely removed Windows from my computer and installed Linux. Initially, it was Ubuntu, but now it’s Fedora. And it’s been running excellently from day one. Fast, smooth, customizable, expandable, and doesn’t get in my way. And since I’ve been working with open-source software on Windows for a while, I don’t miss anything after the switch. To bond a bit more with Linux, I rewatched the documentary “Revolution OS” and read the great books “Just for Fun: The Story of an Accidental Revolutionary” and “Rebel Code: Linux and the Open Source Revolution.” And I have to say, I feel absolutely great about my, in hindsight, much too late decision. Goodbye, Windows. *** The used title graphic of Tux was created by Frank Souza under the Creative Commons Attribution license.",
"tags" : "personal * it"
},
{
"url" : "/blog/duesseldorf.html",
"date" : "31.12.2023",
"title" :"Düsseldorf",
"content" : "I had a few photos on my Pixel phone that I wanted to edit, so it was time to deal with RAW converters. As impressive as the scope of RawTherapee was, I ended up with Darktable. For me, Darktable was more intuitive and allowed me to quickly achieve my desired photo look.",
"tags" : "photos * personal"
},
{
"url" : "/blog/powershell-obfuscation.html",
"date" : "02.05.2023",
"title" :"Powershell Obfuscation",
"content" : "Powershell Obfuscation 02.05.2023 IntroDue to its deep roots on Windows systems and access to .NET libraries, Powershell is a powerful tool for administrators and attackers alike. It offers a wide range of possibilities to write regular and malicious script code and obfuscate it to the point of unreadability and undetectability by antiviruses. Moreover the code can be executed directly in memory, so that no files and further traces are left on the drive. The using of Powershell allows an attacker initial access to the victim system - for example through phishing attachments - as well as to move laterally on the victim network and inject further malicious code. So it is not surprising that this tool stands at the top of the attacker tool list. Be it through self-written and obfuscated code or through frameworks, such as Empire and PowerSploit. In this blog post I will show many of the attacker methods to obfuscate and hide malicious Powershell code and how to detect and analyze it. The shown obfuscation techniques must not stand alone but can also be used in combination. PowershellPowershell offers a variety of ways to obfuscate the script code. In the following the language-specific features of Powershell are described, that are suitable for script obfuscation. Function OverwritingPowershell offers built-in functions (Cmdlets) that can be overridden in the profiles. This way malicious code can be added to a regular Cmdlet, which is executed in the background when the Cmdlet is called. In the following example the build-in function Get-ChildItem is extended through the profile.function Get-ChildItem Microsoft. PowerShell. Management#92;Get-ChildItem # malicious code... Write-Output [+] Malicious code executed!# PS> Get-ChildItem## Directory: C:#92;Users#92;Victim#92;Desktop#92;Files## Mode LastWriteTime Length Name# ---- ------------- ------ ----# -a---- 01.05.2023 13:05 0 file1# -a---- 01.05.2023 13:05 0 file2# -a---- 01.05.2023 13:05 0 file3## [+] Malicious code executed!AliasesPowershell allows a large number of alternative notations and abbreviations for built-in functions, which can be viewed using the 'Get-Alias' command. Parameters can also be abbreviated as desired, as long as there are no ambiguities (e.g. 'ExecutionPolicy' to 'ep' or 'exe'). All of the commands listed below result in identical output. Write-Output Malicious code executed!write Malicious code executed!echo Malicious code executed!# PS> Malicious code executed!Calloperators, WildcardsWith the call operators ('' or '.') a function can be called. In combination with the 'Get-Command' function (abbr. 'gcm'), which enables the command search with the wildcard character '*', a command call can be shortened and thus obfuscated.(gcm *te-Ou*) Malicious code executed!# PS> Malicious code executed!Case, Escape-, WhitespacecharactersThere is no distinction between upper and lower case. Spaces are ignored regardless of their length, allowing malicious code to be hidden at the end of a regular command. The backtick '`' is used as an escape character. Unless this is used before a predefined character such as '`n' for a new line or '`t' for a tab, it is also ignored.(`wR+ It`e + -o+ut`Put) `Ma`licious` code e`xecuted`!# PS> Malicious code executed!.NET-FunctionsThrough .NET access, the .NET functions can also be addressed instead of native Powershell functions.[System. Console]::WriteLine(Malicious code executed!)# PS> Malicious code executed!SpecialcharactersAnother obfuscation option is to assign special character variables '' to integers, which can be incremented through the increment operator '++' and casted to suitable characters. The special variable assignment using '' allows the use of special characters (including spaces) as variable identifiers. The cast operator and required Cmdlets - such as 'iex' - can be assembled using the subexpression operator '()', method resolutions and array index operators. The following special character command was obfuscated with Invoke-Obfuscation by Daniel Bohannon.~==+();~^=~=;=[=++~=;+-=++~=;=-^=++~=;*]=++~=;~``=++~=;)^=++~=;)=++~=;^=++~=;.]=++~=;``=[+()[)]+()[=[.]]+()[+-~^]+?[=[]+];~==.(()[=[*]]+()[=[)^]+()[~^]+()[*]]+?[=[]+()[=-^]);~==()[=[+*]]+()[*]]+~=[+-+)];.~=(``^)+``=[=[*]+``=[~^~``+``=[=[)^+``=[~^=[+``*]~``+``).]+``=[=[)+``=[=[)^+``=[=[+-+``=[=[)+``=[=[)^+``=-^+-+``=-^.]+``))+``.])+``=[~^^+``=[~^~``+``.].]+``=[~^~``+``=[=[=[+``=[=[)+``=[=[~``+``=-^+-+``.].]+``=[=[=[+``=[~^~^+``=[~^=[+``=-^+-+``=[~^=[+``=[+-~^+``=[~^=[+``.].]+``=[=[)+``=[=[)^+``=[~^=[+``=[~^~^+``=-^=-^+``=-^.]|~=)# PS> Malicious code executed!The Powershell code after resolving the special characters:[CHar]87+[CHar]114+[CHar]105+[CHar]116+[CHar]101+[CHar]45+[CHar]79+[CHar]117+[CHar]116+[CHar]112+[CHar]117+[CHar]116+[CHar]32+[CHar]39+[CHar]77+[CHar]97+[CHar]108+[CHar]105+[CHar]99+[CHar]105+[CHar]111+[CHar]117+[CHar]115+[CHar]32+[CHar]99+[CHar]111+[CHar]100+[CHar]101+[CHar]32+[CHar]101+[CHar]120+[CHar]101+[CHar]99+[CHar]117+[CHar]116+[CHar]101+[CHar]100+[CHar]33+[CHar]39|iex# PS> Malicious code executed!The final code after resolving the byte characters:Write-Output 'Malicious code executed!' | iex# PS> Malicious code executed!StringsIn the following common string obfuscation techniques are shown, which can be used with any programming language in this or similar form. ChainingCharacters can be concatenated by '-split', '-join' or the '+' sign. Write-Output (Malicious + + code + + executed!)Write-Output (MaliciousXXXcodeXXXexecuted! -split XXX -join )# PS> Malicious code executed!ReplacingCharacter strings can be exchanged using the '-replace' option. Write-Output (MaliciousXXXcodeXXXexecuted! -replace(XXX, ))# PS> Malicious code executed!FormatoperatorThe format operator '-f' can be used to rearrange strings based on number order. Write-Output (1 0 2 -f code, Malicious, executed!)# PS> Malicious code executed!ReversingCharacters can be reversed via array slicing. Write-Output (-join !detucexe edoc suoicilaM[24 .. 0])# PS> Malicious code executed!EncodingObfuscation can also be achieved using common encoding methods. Base64The code to be executed can be encoded and passed to Base64. The command encoded in this way can be started via Powershell with the '-EncodedCommand' option.[Convert]::ToBase64String([Text. Encoding]::Unicode. GetBytes(Write-Output 'Malicious code executed!')) | Write-Host# PS> VwByAGkAdABlAC0ATwB1AHQAcAB1AHQAIAAnAE0AYQBsAGkAYwBpAG8AdQBzACAAYwBvAGQAZQAgAGUAeABlAGMAdQB0AGUAZAAhACcApowershell -EncodedCommand VwByAGkAdABlAC0ATwB1AHQAcAB1AHQAIAAnAE0AYQBsAGkAYwBpAG8AdQBzACAAYwBvAGQAZQAgAGUAeABlAGMAdQB0AGUAZAAhACcA# PS> Malicious code executed!ASCIIASCII-encoded commands can be executed after a byte conversion, for example via 'Invoke-Expression'.[Text. Encoding]::ASCII. GetBytes(Write-Output 'Malicious code executed!') | Out-String | ForEach-Object _. Replace(`n,,).TrimEnd(,)# PS> 87,114,105,116,101,45,79,117,116,112,117,116,32,39,77,97,108,105,99,105,111,117,115,32,99,111,100,101,32,101,120,101,99,117,116,101,100,33,39Invoke-Expression( -join [char[]](87,114,105,116,101,45,79,117,116,112,117,116,32,39,77,97,108,105,99,105,111,117,115,32,99,111,100,101,32,101,120,101,99,117,116,101,100,33,39))# PS> Malicious code executed!HexThe use of hex encoding is possible in a similar way.[Text. Encoding]::UTF8. GetBytes(Write-Output 'Malicious code executed!') | ForEach-Object ' + _. ToString(X2) + ' | Out-String | ForEach-Object _. Replace(`n,,).TrimEnd(,)# PS> '57','72','69','74','65','2D','4F','75','74','70','75','74','20','27','4D','61','6C','69','63','69','6F','75','73','20','63','6F','64','65','20','65','78','65','63','75','74','65','64','21','27'Invoke-Expression( -join ('57','72','69','74','65','2D','4F','75','74','70','75','74','20','27','4D','61','6C','69','63','69','6F','75','73','20','63','6F','64','65','20','65','78','65','63','75','74','65','64','21','27' | ForEach-Object ([Convert]::ToInt16(_. ToString(),16) -as [char]) ))# PS> Malicious code executed!OctalSimilar with octal encoding.[Text. Encoding]::UTF8. GetBytes(Write-Output 'Malicious code executed!') | ForEach-Object [Convert]::ToString(_, 8) | Out-String | ForEach-Object _. Replace(`n,,).TrimEnd(,)# PS> 127,162,151,164,145,55,117,165,164,160,165,164,40,47,115,141,154,151,143,151,157,165,163,40,143,157,144,145,40,145,170,145,143,165,164,145,144,41,47Invoke-Expression( -join (127,162,151,164,145,55,117,165,164,160,165,164,40,47,115,141,154,151,143,151,157,165,163,40,143,157,144,145,40,145,170,145,143,165,164,145,144,41,47 | ForEach-Object ([Convert]::ToInt16(_. ToString(),8) -as [char]) ))# PS> Malicious code executed!BinaryAnd the same with binary encoding.[Text. Encoding]::UTF8. GetBytes(Write-Output 'Malicious code executed!') | ForEach-Object [Convert]::ToString(_, 2) | Out-String | ForEach-Object _. Replace(`n,,).TrimEnd(,)# PS> 1010111,1110010,1101001,1110100,1100101,101101,1001111,1110101,1110100,1110000,1110101,1110100,100000,100111,1001101,1100001,1101100,1101001,1100011,1101001,1101111,1110101,1110011,100000,1100011,1101111,1100100,1100101,100000,1100101,1111000,1100101,1100011,1110101,1110100,1100101,1100100,100001,100111Invoke-Expression( -join (1010111,1110010,1101001,1110100,1100101,101101,1001111,1110101,1110100,1110000,1110101,1110100,100000,100111,1001101,1100001,1101100,1101001,1100011,1101001,1101111,1110101,1110011,100000,1100011,1101111,1100100,1100101,100000,1100101,1111000,1100101,1100011,1110101,1110100,1100101,1100100,100001,100111 | ForEach-Object ([Convert]::ToInt16(_. ToString(),2) -as [char]) ))# PS> Malicious code executed!EncryptionXOR- and SecureString encryption are shown below. Because of the .NET interface all the other .NET encryption algorithms can also be used with Powershell. XORA command can be obfuscated using XOR and converted back again. The following example performs an XOR operation on each byte of the instruction with the value '0x42'. The bytes can be reconverted with the same value and ASCII casting.[Text. Encoding]::UTF8. GetBytes(Write-Output 'Malicious code executed!') | ForEach-Object _ -bxor 0x42 | Out-String | ForEach-Object _. Replace(`n,,).TrimEnd(,)# PS> 21,48,43,54,39,111,13,55,54,50,55,54,98,101,15,35,46,43,33,43,45,55,49,98,33,45,38,39,98,39,58,39,33,55,54,39,38,99,101Invoke-Expression (-join (21,48,43,54,39,111,13,55,54,50,55,54,98,101,15,35,46,43,33,43,45,55,49,98,33,45,38,39,98,39,58,39,33,55,54,39,38,99,101 | ForEach-Object [char](_ -bxor 0x42) ))# PS> Malicious code executed!SecureString (AES)A command can be AES encrypted by using the SecureString function.# 16, 24 or 32 byte key sizekey = ([Text. Encoding]::Default. GetBytes(MySecretPassword))Write-Output 'Malicious code executed!' | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString -Key key# PS> 01000000d08c9ddf0115d1118c7a00c04fc297eb01000000178e91759fcacf468c330156d58c66bc000000000200000000001066000000010000200000003a3a0b242a307a48d03f6e105db3e209fa3b58021775721753365e5e72bc4f56000000000e8000000002000020000000cf4f9098c27d1aeeb7ba3ecd88252461b812830d3ea934b54e135c270c174a0e500000009e08b1ff1bc319d94ff2611253ecefdc46bb64e5a8a55ed2457cfc516ff6512cdebf9466e52452e4495e1582e2c048097fe6e317ad00692147dd03c8d6db7995028a534a807f22b44d720ebc80d9788a40000000c026f435426f31cdca4c087487fd32ea9ab53498ad8de3bfd2a73b27a59deb46f41c6670f3641a20323573e29ed04d0cc60d07ca3efcec0c6069bcda3d30edbbInvoke-Expression( ([Runtime. InteropServices. Marshal]::PtrToStringAuto([Runtime. InteropServices. Marshal]::SecureStringToBSTR( (01000000d08c9ddf0115d1118c7a00c04fc297eb01000000178e91759fcacf468c330156d58c66bc000000000200000000001066000000010000200000003a3a0b242a307a48d03f6e105db3e209fa3b58021775721753365e5e72bc4f56000000000e8000000002000020000000cf4f9098c27d1aeeb7ba3ecd88252461b812830d3ea934b54e135c270c174a0e500000009e08b1ff1bc319d94ff2611253ecefdc46bb64e5a8a55ed2457cfc516ff6512cdebf9466e52452e4495e1582e2c048097fe6e317ad00692147dd03c8d6db7995028a534a807f22b44d720ebc80d9788a40000000c026f435426f31cdca4c087487fd32ea9ab53498ad8de3bfd2a73b27a59deb46f41c6670f3641a20323573e29ed04d0cc60d07ca3efcec0c6069bcda3d30edbb | ConvertTo-SecureString -Key key)))))# PS> Malicious code executed!CompressionIn Powershell the RAW- and GZip compressions are mainly used. RAWThe command can be compressed and encoded as Base64. It can be decoded or decompressed in the reverse order.memory_stream = New-Object IO. MemoryStreamcompressor = New-Object IO. Compression. DeflateStream(memory_stream, [IO. Compression. CompressionMode]::Compress)stream_writer = New-Object IO. StreamWriter(compressor)stream_writer. Write(Write-Output 'Malicious code executed!')stream_writer. Close()[System. Convert]::ToBase64String(memory_stream. ToArray())# PS> Cy/KLEnV9S8tKSgtUVD3TczJTM7MLy1WSM5PSVVIrUhNLi1JTVFUBwA=Invoke-Expression(New-Object IO. StreamReader((New-Object IO. Compression. DeflateStream([IO. MemoryStream][Convert]::FromBase64String(Cy/KLEnV9S8tKSgtUVD3TczJTM7MLy1WSM5PSVVIrUhNLi1JTVFUBwA=),[IO. Compression. CompressionMode]::Decompress)),[Text. Encoding]::ASCII)).ReadToEnd()# PS> Malicious code executed!GZipThe compression is done the same as in RAW except that the 'GZipStream' function is used.memory_stream = New-Object IO. MemoryStreamcompressor = New-Object IO. Compression. GZipStream(memory_stream, [IO. Compression. CompressionMode]::Compress)stream_writer = New-Object IO. StreamWriter(compressor)stream_writer. Write(Write-Output 'Malicious code executed!')stream_writer. Close()[System. Convert]::ToBase64String(memory_stream. ToArray())# PS> H4sIAAAAAAAEAAsvyixJ1fUvLSkoLVFQ903MyUzOzC8tVkjOT0lVSK1ITS4tSU1RVAcAcDv1sCcAAAA=Invoke-Expression(New-Object IO. StreamReader((New-Object IO. Compression. GZipStream([IO. MemoryStream][Convert]::FromBase64String(H4sIAAAAAAAEAAsvyixJ1fUvLSkoLVFQ903MyUzOzC8tVkjOT0lVSK1ITS4tSU1RVAcAcDv1sCcAAAA=),[IO. Compression. CompressionMode]::Decompress)),[Text. Encoding]::ASCII)).ReadToEnd()# PS> Malicious code executed!PersistencePowershell code can be hidden at operating system level, so that no malicious script files have to be applied to the victim system. This way persistence can be achieved on the system or the anti-virus protection can be bypassed. The following shows ways in which Powershell code can be applied to the system and executed without dropping files. ProfileAs described at 'Function Overwriting' the native Powershell functions can be overwritten system- and user-wide using Powershell profiles. This way malicious code can be executed automatically as soon as Powershell is started. An automated start of Powershell in the background can be forced via the Task Scheduler or WMI for example. The following code was saved in the user profile file, which is always executed automatically when Powershell is started.# Microsoft. PowerShell_profile.ps1Write-Output Malicious code automatically executed from: (PSCommandPath)# PS> Malicious code automatically executed from: C:#92;Users#92;Victim#92;Documents#92;WindowsPowerShell#92;Microsoft. PowerShell_profile.ps1Task SchedulerPowershell code can be persisted and executed from the Task Scheduler. In the following a Powershell window with the output listed below is displayed every minute.action = New-ScheduledTaskAction -Execute powershell.exe -Argument -ep bypass -NoExit -c Write-Output 'Malicious code executed every minute!'trigger = New-ScheduledTaskTrigger -Once -At (Get-Date) -RepetitionInterval (New-TimeSpan -Minutes 1)principal = New-ScheduledTaskPrincipal -UserId env:username -LogonType InteractiveRegister-ScheduledTask -TaskName MALICIOUS -Action action -Trigger trigger -Principal principal# PS> Malicious code executed every minute!RegistryPowershell code can also be stored in the Registry. Here the command is first base64-encoded and stored in a newly created registry key 'XXX'. The value can then be read out with Powershell.reg_val = [Convert]::ToBase64String([Text. Encoding]::Unicode. GetBytes(Write-Output 'Malicious code executed!'))New-Item HKCU:#92;SOFTWARE -Name MalsoftNew-ItemProperty HKCU:#92;SOFTWARE#92;Malsoft -Name XXX -Value reg_valpowershell -EncodedCommand (Get-ItemProperty HKCU:#92;SOFTWARE#92;Malsoft -Name XXX).XXX# PS> Malicious code executed!EnvironmentvariableThe environment variables also offer the possibility to save Powershell code. In the following example the environment variable 'XXX' is created, where a base64-encoded Powershell command is stored. The command can then be invoked using the environment variable value.env_var = [Convert]::ToBase64String([Text. Encoding]::Unicode. GetBytes(Write-Output 'Malicious code executed!'))[Environment]::SetEnvironmentVariable(XXX, env_var, [EnvironmentVariableTarget]::User)powershell -EncodedCommand ([Environment]::GetEnvironmentVariable(XXX))# PS> Malicious code executed!Environment variables can also be used in this way to create a Cmdlet or a command from individual characters. In the following the abbreviation for the Invoke-Expression Cmdlet 'iex' is created of the ComSpec environment variable from the 4th, 26th and 25th character (counted from 0).env:ComSpec# PS> C:#92;Windows#92;system32#92;cmd.exe(env:ComSpec[4,26,25]-join'') (Write-Output 'Malicious code executed!')# PS> Malicious code executed!Windows Management Instrumentation (WMI)Windows Management Instrumentation offers the possibility of reacting to specific events using Event Filters, such as logging onto a system, the start of a specific process or the reaching of a specific date and time. This event can then be linked to an Consumeraction, which can be used to execute PowerShell code. The following code sets an Event Filter, that triggers every minute at second 42. This filter is connected to a 'CommandLineEventConsumer', which executes the obfuscated PowerShell code, which leads to the output via 'msg.exe'. The configuration saved in this way remains also active after a system restart.# Filterfilter = Set-WmiInstance -Namespace root#92;subscription -Class __EventFilter -Arguments Name = MyEventFilter EventNameSpace = root#92;cimv2 QueryLanguage = WQL Query = SELECT * FROM __InstanceModificationEvent WHERE TargetInstance ISA 'Win32_LocalTime' AND TargetInstance. Second=42# Consumerconsumer = Set-WmiInstance -Namespace root#92;subscription -Class CommandLineEventConsumer -Arguments Name = MyEventConsumer CommandLineTemplate = powershell.exe -ExecutionPolicy Bypass -EncodedCommand bQBzAGcALgBlAHgAZQAgACoAIAAnAE0AYQBsAGkAYwBpAG8AdQBzACAAYwBvAGQAZQAgAGUAeABlAGMAdQB0AGUAZAAhACcA# BindingSet-WmiInstance -Namespace root#92;subscription-Class __FilterToConsumerBinding-Arguments Filter = filter Consumer = consumer Alternate Data Streams (ADS)ADS is an NTFS feature, which allows to append several data streams to a file. The default data stream is stored in the 'DATA' attribute. In the following a base64-encoded command is written to another stream of a regular file named 'hidden', which then can be executed by getting the contents of this hidden stream. Set-Content '.#92;RegularFile.txt' -Stream hidden -Value VwByAGkAdABlAC0ATwB1AHQAcAB1AHQAIAAnAE0AYQBsAGkAYwBpAG8AdQBzACAAYwBvAGQAZQAgAGUAeABlAGMAdQB0AGUAZAAhACcApowershell -ec (Get-Content '.#92;RegularFile.txt' -Stream 'hidden')# PS> Malicious code executed!ToolsThis section describes some tools to detect and analyze obfuscated Powershell code. EventlogSince Powershell 5 the call to arguments and commands of typical obfuscated scripts - such as 'Bypass', 'FromBase64String', 'DeflateStream' - are automatically logged along with its contents at the warning level in the following event log under event ID 4104. Microsoft-Windows-PowerShell4Operational.evtx To get more inside of the logged obfuscated script, it is recommended to turn on 'Script Block Logging' in the Group Policy. Group Policy > Computer Configuration > Administrative Templates > Windows PowerShell > Turn on PowerShell Script Block LoggingBy activating 'Script Block Logging' the resolved script block layers are additionally logged at the verbose level under event ID 4104 For an even deeper logging of Powershell scripts the 'Module Logging' and 'PowerShell Transcription' can also be activated in the Group Policy. Revoke-ObfuscationRevoke-Obfuscation is a Powershell module by Daniel Bohannon, which is using two main functions 'Get-RvoScriptBlock' and 'Measure-RvoObfuscation'.The function 'Get-RvoScriptBlock' enables the extraction of local or extern Eventlogs, while the function 'Measure-RvoObfuscation' is trying to classify a Powershell script as obfuscated or not. This function takes whole Powershellscript files or extracted script blocks as input. In the following example the script blocks of the Powershell Eventlog are extracted through 'Get-RvoScriptBlock' and then analyzed through 'Measure-RvoObfuscation'.skriptblock = Get-WinEvent Microsoft-Windows-PowerShell/Operational | Get-RvoScriptBlock | Measure-RvoObfuscation -VerboseThe output shows the recognized obfuscated scripts and their hash values....[34 of 46] NOT OBFUSCATED :: (34496E64527BF40DEAD53CF193D97E55F3...)[35 of 46] NOT OBFUSCATED :: (B5CA27664A1E634B4E551F638FF3A4ACD9...)[36 of 46] OBFUSCATED :: (FF19200070919B612CAFDDBC1F03541FAE...)[37 of 46] OBFUSCATED :: (25E323F9DA18AC845E1C436538C74A2D82...)...The scripts can been viewed over the index (-1) of the previously defined variable.skript_block[35].Source# ScriptBlock=.(021-f'seT','item','-') ('vaRI'+'ABLE'+':U'+'7…Chainsaw, HayabusaChainsaw and Hayabusa are both CLI applications, which are working with Sigma rules to scan one or more Eventlogs. The applications can be executed with the following commands to scan for suspicious Powershell code:chainsaw-2.5.0.exe hunt .#92;Microsoft-Windows-PowerShell4Operational.evtx -s sigma/ --mapping mappings/sigma-event-logs-all.ymlhayabusa-2.2.2.exe csv-timeline -f .#92;Microsoft-Windows-PowerShell4Operational.evtxBesides obfuscation rules, there are several other rules for suspicious Powershell code among others:Rule Suspicious Script---- -----------------Powershell Token Obfuscation obfuscated.ps1Change PowerShell Policies to an Insecure Level obfuscated.ps1Malicious PowerShell Keywords obfuscated.ps1Potential WinAPI Calls Via PowerShell Scripts obfuscated.ps1Suspicious PowerShell Keywords obfuscated.ps1...THORTHOR and the free THOR-lite CLI applications are also working with Sigma rules. Furthermore they are using YARA rules, so obfuscated or suspicious Powershell code can be recognized in other files. For example in LNK files, which can contain malicious Powershell code to load further code or files. PSDecodePSDecode is a helpful Powershell module when analyzing obfuscated Powershell code manually. It can recognize and reverse typical obfuscation techniques - like base64- or string obfuscation - so the analyzed code can become much more readable for further analysis. Intro Powershell Function Overwriting Aliases Calloperators, Wildcards Case, Escape-, Whitespacechars .NET-Functions Specialchars Strings Chaining Replacing Formatoperator Reversing Encoding Base64 ASCII Hex Octal Binary Encryption XOR SecureString (AES) Compression RAW GZip Persistence Profile Task Scheduler Registry Environmentvar WMI ADS Tools Eventlog Revoke-Obfuscation Chainsaw, Hayabusa THOR PSDecode",
"tags" : "infosec"
},
{
"url" : "/blog/cuckoos-egg.html",
"date" : "03.09.2022",
"title" :"Cuckoos Egg",
"content" : "This book from Cliff Stoll was always at the end of my reading queue. Infosec is a fast paced area and what should I learn from an over 35 year old incident? Actually this book aged very well and is still relevant in this area. It describes basically the beginnings of DFIR. On the German side the case is better known because of the events surrounding the KGB hacks and the death of the hacker Karl Koch, which were made into a movie1 and a book2.*** Hans-Christian Schmid: 23 - Nichts ist so wie es scheint. 1998 Hans-Christian Schmid, Michael Gutmann: 23 - Die Geschichte des Hackers Karl Koch. Deutscher Taschenbuch-Verlag, München 1999, ISBN 3-423-08477-4",
"tags" : "books * infosec"
},
{
"url" : "/blog/this-is-how-they-tell-me-the-world-ends.html",
"date" : "28.07.2022",
"title" :"This Is How They Tell Me The World Ends",
"content" : "A well written and well researched book from Nicole Perlroth about the evolution of IT security and IT politics. Provides a good overview in this field. Enjoyed the read.",
"tags" : "books * infosec"
},
{
"url" : "/blog/jibaro.html",
"date" : "27.05.2022",
"title" :"Jibaro",
"content" : "Two hunters attracted against their nature by the fascination of the unattainable, allow closeness, wear themselves out against each other to succumb to their urges in the end. An excellent 17 minute animation by Alberto Mielgo, whose work with The Witness already stood out with his distinctive style in the first season of the animation series Love Death + Robots.",
"tags" : "films"
},
{
"url" : "/blog/unkraine-war.html",
"date" : "19.03.2022",
"title" :"Ukraine War",
"content" : "Ukraine War 19.03.2022 On Feb. 24, 2022, Putin, with the support of the Belarusian regime, invades Ukraine with his troops, plunging Europe into war. My initial fears that Ukraine would quickly fall in the face of Russia's supposed military superiority have not come true. The Ukrainians have been steadfastly resisting the invasion for over three weeks and are bravely defending their country and their freedom. I am incredibly glad that especially with the current events in the USA, a real politician is president again, instead of the Trump clown, who blathers about a brilliant operation and a peace mission and with whom there would certainly not be the military and financial support of the West that there is now for Ukraine. Germany's government unfortunately gives a very weak picture so far. As one of the last countries it blocked many sanctions against Russia, such as the SWIFT exclusion or the import of Russian oil and gas, and supplies obsolete equipment to Ukraine. After an impressive speech of the President of Ukraine Selenskyj in the Bundestag and the indirect accusation of Germany's lack of support, the Bundestag silently goes over to the agenda. I am all the more pleased that the rest of the world is showing its support for Ukraine and isolating Russia more and more. Even Russia-friendly China is staying neutral and increasingly sending signals that it does not support this war. The Russian regime is doing what it has always done. It spreads lies, makes critics disappear, locks up demonstrators and dreams of old Soviet times. Especially for this war, the letter Z is symbolized, like the swastika in the Nazi era. The letter is painted on military vehicles and waved on flags at propaganda events. Every day the Russian military commits war crimes in Ukraine, where fleeing civilians are overrun by tanks and their homes, hospitals and kindergartens are bombed to break the population and its resistance. Besides my financial and moral support, I can only hope for a quick end to the war and that Putin and his supporters end up before the International Criminal Court for his crimes after their historic defeat. That Ukraine regains its old sovereignty, together with its old state borders, and that its path into the European Union is prepared as quickly as possible. It has proven, that it is a country that defends the values of democracy and freedom to the utmost. After that, it is only a matter of time until other countries will break away from Russia's coercive influence and follow Ukraine's example. Russia itself faces a dark future due to its isolation, similar to North Korea. Whether China will tie itself to another North Korea is questionable, but because of the many Russian resources, it is not unlikely. I can only hope for the sake of the world community that Russia will follow in the near future the example of Ukraine and initiate a democratic process after the overthrow of the dictator Putin, which could bring us much closer to world peace. ***",
"tags" : "personal"
},
{
"url" : "/blog/hello-world.html",
"date" : "16.01.2022",
"title" :"Hello World!",
"content" : "Oh, hello! I am Alex, nice to meet you! May I introduce my new website. It was a long time ago when I first started with HTML. The year was 1999, a time when fidgety glitter GIFs and background music in MIDI format were still en vogue, celebrating the brave new internet world in a loud and colorful way. Then in 2006 I tried my first walking attempts with a public homepage. This has been offline for a long time, but a digital copy can still be viewed at archive.org, as the internet never forgets. It all started with static HTML pages, followed by a “content management system” called WordPress. Nice were the times before “social” networks and influencers. When people maintained a personal website with care, presented their hobbies and got in touch and discussed with like-minded. Without cookie banners, advertising hell and spreading hate (because stupidity could not do HTML in the past). Back then, my hobbies included 2D and 3D graphics, as well as everything related to motorcycles. At some point, social networks came along, which are still based on the good idea of offering less tech-savvy people a stage to the outside world. Unfortunately, many idiots, who don’t get any attention locally, because they are seen as such, also take advantage of the easy entry. They have shown that they are capable of registering on such platforms and networking with other less intelligent individuals. And so the Internet is overrun these days by noisy hordes who think they have expertise in all fields. Clowns like Trump are elevated to their kings. Countries split off after votes, making themselves worse off than before. Crude theories, world conspiracies and “own research” are spread, instead of listening to the professionals who have dedicated their whole lives to their subject and build on the knowledge of their countless predecessors. Those professionals who are currently battling waves of idiocy in climate rescue and pandemic response. Crazy world. But if history can do one thing, it’s outlast idiocy. Cheers to the many quiet and reasonable people who do not let themselves be defeated even in difficult times and slowly but steadily move humanity forward!Well, so be it. Where was I? Oh well, sometime in 2012, I decided to learn programming. Even though I didn’t stick with it with the vehemence I wish I had in hindsight, I can say that I now understand the concept behind it and am ready to take it a step further. And so, it was obvious to combine my passion for graphics and programming, which finally led to this website. First and foremost, I want to publish small, elegant programs for Windows and Linux, which are not overloaded with countless options and so, maybe in their own way, can contribute to making daily life less cumbersome.",
"tags" : "personal"
}
]